name: Scheduled Key Vault Certificate Renewal

on:
  workflow_dispatch: # Allows manual triggering
  schedule:
    - cron: '0 0 * * *' # Runs once every 24 hours at midnight UTC

env:
  # Define environment variables for your certificate and Key Vault details
  CERT_FRIENDLY_NAME: "IIS-Key-Vault"           # The friendly name for your certificate
  CERT_COMMON_NAME: "IIS-Key-Vault"            # The Common Name (CN) / primary DNS name for the cert
  CERT_VALIDITY_DAYS: "30"                     # How long the newly generated certificate will be valid (in days)
  RENEWAL_THRESHOLD_DAYS: "30"                 # Number of days before expiration to trigger renewal
  KEY_VAULT_NAME: "samuelkv"                   # Your Azure Key Vault name
  CERTIFICATE_NAME_IN_KV: "IIS-Key-Vault" # Name of the certificate in Key Vault

jobs:
  renew_cert_if_needed:
    runs-on: windows-latest # Use a Windows runner for PowerShell certificate cmdlets

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true

      - name: Install Latest Az PowerShell Modules
        shell: pwsh
        run: |
          Set-PSRepository -Name PSGallery -InstallationPolicy Trusted -ErrorAction Stop
          Install-Module -Name Az -Force -AllowClobber -Scope CurrentUser -ErrorAction Stop
          Import-Module Az -ErrorAction Stop
          Write-Host "Az modules updated and imported successfully."

      - name: Check Certificate Expiration
        id: check_expiry # Assign an ID to this step to access its outputs
        shell: pwsh
        env:
          AZURE_CREDS_JSON: ${{ secrets.AZURE_CREDENTIALS }}
          SP_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
          AZURE_SUBSCRIPTION_ID_FROM_CREDS: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        run: |
          # --- Authenticate to Azure for Key Vault access ---
          $Creds = ConvertFrom-Json -InputObject $env:AZURE_CREDS_JSON
          $TenantId = $Creds.tenantId
          $ClientId = $Creds.clientId
          $SubscriptionId = $env:AZURE_SUBSCRIPTION_ID_FROM_CREDS
          $ClientSecret = $env:SP_CLIENT_SECRET
          
          $SecureClientSecret = ConvertTo-SecureString -String $ClientSecret -AsPlainText -Force
          $Credential = New-Object System.Management.Automation.PSCredential($ClientId, $SecureClientSecret)
          Add-AzAccount -Credential $Credential -ServicePrincipal -TenantId $TenantId -SubscriptionId $SubscriptionId -ErrorAction Stop

          Import-Module Az.KeyVault -ErrorAction Stop
          
          $KeyVaultName = "${{ env.KEY_VAULT_NAME }}"
          $CertificateName = "${{ env.CERTIFICATE_NAME_IN_KV }}"
          $RenewalThreshold = ${{ env.RENEWAL_THRESHOLD_DAYS }} # Get threshold from env

          Write-Host "Retrieving certificate '$CertificateName' from Key Vault '$KeyVaultName'..."
          try {
              $cert = Get-AzKeyVaultCertificate -VaultName $KeyVaultName -Name $CertificateName -ErrorAction Stop
              $currentExpiryDate = $cert.Expires
              Write-Host "Current certificate '$CertificateName' expires on: $currentExpiryDate"
          }
          catch {
              Write-Error "Failed to retrieve certificate '$CertificateName'. Error: $($_.Exception.Message)"
              Write-Host "Assuming certificate does not exist or access denied. Setting daysRemaining to 0 to trigger creation/renewal."
              echo "daysRemaining=0" >> $env:GITHUB_OUTPUT # Set to 0 to force creation if it doesn't exist or can't be retrieved
              exit 0 # Exit successfully so the next step (conditional) can evaluate
          }

          $daysRemaining = ($currentExpiryDate - (Get-Date)).Days
          Write-Host "Days remaining until expiration: $daysRemaining"
          Write-Host "Renewal threshold: $RenewalThreshold days."

          # Output days remaining for the next step's conditional
          echo "daysRemaining=$daysRemaining" >> $env:GITHUB_OUTPUT
          echo "renewalNeeded=$($daysRemaining -le $RenewalThreshold)" >> $env:GITHUB_OUTPUT # Output true/false

      - name: Generate and Upload New PFX (Conditional)
        id: generate_upload_pfx # Assign an ID to this step
        shell: pwsh
        # Only run this step if 'renewalNeeded' is true from the previous step
        if: steps.check_expiry.outputs.renewalNeeded == 'true'
        env:
          AZURE_CREDS_JSON: ${{ secrets.AZURE_CREDENTIALS }}
          SP_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
          AZURE_SUBSCRIPTION_ID_FROM_CREDS: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        run: |
          Write-Host "Certificate renewal needed. Proceeding to generate and upload new PFX."

          # --- Authenticate to Azure for Key Vault access ---
          $Creds = ConvertFrom-Json -InputObject $env:AZURE_CREDS_JSON
          $TenantId = $Creds.tenantId
          $ClientId = $Creds.clientId
          $SubscriptionId = $env:AZURE_SUBSCRIPTION_ID_FROM_CREDS
          $ClientSecret = $env:SP_CLIENT_SECRET
          
          $SecureClientSecret = ConvertTo-SecureString -String $ClientSecret -AsPlainText -Force
          $Credential = New-Object System.Management.Automation.PSCredential($ClientId, $SecureClientSecret)
          Add-AzAccount -Credential $Credential -ServicePrincipal -TenantId $TenantId -SubscriptionId $SubscriptionId -ErrorAction Stop

          Import-Module Az.KeyVault -ErrorAction Stop

          # --- Certificate Generation ---
          $certFriendlyName = "${{ env.CERT_FRIENDLY_NAME }}"
          $certCommonName = "${{ env.CERT_COMMON_NAME }}"
          $validityDays = ${{ env.CERT_VALIDITY_DAYS }}
          $pfxPassword = ConvertTo-SecureString -String "${{ secrets.PFX_PASSWORD }}" -Force -AsPlainText
          
          Write-Host "Generating new self-signed certificate with Friendly Name: '$certFriendlyName' and Common Name: '$certCommonName'..."

          $cert = New-SelfSignedCertificate `
              -DnsName $certCommonName `
              -CertStoreLocation "Cert:\CurrentUser\My" `
              -FriendlyName $certFriendlyName `
              -NotAfter (Get-Date).AddDays($validityDays) `
              -KeyUsage DigitalSignature, KeyEncipherment `
              -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.1,1.3.6.1.5.5.7.3.2", "2.5.29.19={text}CA=FALSE") `
              -ErrorAction Stop

          Write-Host "New certificate generated successfully. Thumbprint: $($cert.Thumbprint)"

          $pfxPath = "C:\temp\$($certFriendlyName).pfx"
          
          if (-not (Test-Path -Path (Split-Path $pfxPath) -PathType Container)) {
              New-Item -Path (Split-Path $pfxPath) -ItemType Directory -Force
          }

          Export-PfxCertificate -Cert $cert -FilePath $pfxPath -Password $pfxPassword -ErrorAction Stop

          Write-Host "PFX file exported to: $pfxPath"
          
          # Output the PFX path and password for the upload step
          echo "pfx_file_path=$pfxPath" >> $env:GITHUB_OUTPUT
          echo "pfx_password_raw=${{ secrets.PFX_PASSWORD }}" >> $env:GITHUB_OUTPUT

          # --- Upload to Azure Key Vault ---
          $KeyVaultName = "${{ env.KEY_VAULT_NAME }}"
          $CertificateNameInKv = "${{ env.CERTIFICATE_NAME_IN_KV }}"
          $pfxPasswordFromOutput = "${{ secrets.PFX_PASSWORD }}" | ConvertTo-SecureString -AsPlainText -Force # Use secret directly or previous output
          
          Write-Host "Importing PFX from '$pfxPath' into Key Vault '$KeyVaultName' as '$CertificateNameInKv'..."

          Import-AzKeyVaultCertificate `
              -VaultName $KeyVaultName `
              -Name $CertificateNameInKv `
              -FilePath $pfxPath `
              -Password $pfxPasswordFromOutput `
              -ErrorAction Stop

          Write-Host "Certificate '$CertificateNameInKv' (Friendly Name: '$certFriendlyName') imported into Key Vault '$KeyVaultName' successfully!"

      - name: Upload PFX as Artifact (Optional, only if generated/uploaded)
        uses: actions/upload-artifact@v4
        # Only run if the 'generate_upload_pfx' step ran and produced an output path
        if: success() && steps.generate_upload_pfx.outputs.pfx_file_path
        with:
          name: ${{ env.CERT_FRIENDLY_NAME }}-pfx
          path: ${{ steps.generate_upload_pfx.outputs.pfx_file_path }} 
          retention-days: 1
