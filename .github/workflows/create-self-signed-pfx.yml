name: Generate Self-Signed PFX Certificate and Upload to Key Vault

on:
  workflow_dispatch: # Allows manual triggering from GitHub UI

env:
  # Define environment variables for your certificate details
  CERT_FRIENDLY_NAME: "IIS-Key-Vault" # The friendly name for your certificate
  CERT_COMMON_NAME: "IIS-Key-Vault"  # The Common Name (CN) / primary DNS name for the cert
  CERT_VALIDITY_DAYS: "30"               # How long the certificate will be valid (in days)
  KEY_VAULT_NAME: "samuelkv"           # Your Azure Key Vault name
  CERTIFICATE_NAME_IN_KV: "IIS-Key-Vault" # Name of the certificate to store in Key Vault

jobs:
  generate_and_upload_pfx:
    runs-on: windows-latest # Use a Windows runner as New-SelfSignedCertificate is a Windows PowerShell cmdlet

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2 # Action to log into Azure using a Service Principal
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }} # GitHub Secret containing your Service Principal JSON
          enable-AzPSSession: true # Crucial for Az PowerShell session setup

      - name: Install Latest Az PowerShell Module (Ensures compatibility)
        shell: pwsh
        run: |
          Set-PSRepository -Name PSGallery -InstallationPolicy Trusted -ErrorAction Stop
          Install-Module -Name Az -Force -AllowClobber -Scope CurrentUser -ErrorAction Stop
          Import-Module Az -ErrorAction Stop
          Write-Host "Az modules updated and imported successfully."

      - name: Generate Self-Signed Certificate and Export PFX
        id: generate_cert_pfx # Assign an ID to this step to capture its outputs
        shell: pwsh
        env:
          # Pass the full AZURE_CREDENTIALS secret string as an environment variable
          AZURE_CREDS_JSON: ${{ secrets.AZURE_CREDENTIALS }}
          # Pass the client secret separately as a dedicated env var (more secure practice)
          SP_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
          # The subscription ID from the credentials
          AZURE_SUBSCRIPTION_ID_FROM_CREDS: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        run: |
          # Define certificate properties from environment variables
          $certFriendlyName = "${{ env.CERT_FRIENDLY_NAME }}"
          $certCommonName = "${{ env.CERT_COMMON_NAME }}"
          $validityDays = ${{ env.CERT_VALIDITY_DAYS }}

          # Parse the AZURE_CREDENTIALS JSON to get SPN details for Connect-AzAccount
          $Creds = ConvertFrom-Json -InputObject $env:AZURE_CREDS_JSON
          $TenantId = $Creds.tenantId
          $ClientId = $Creds.clientId
          # Using the subscription ID from the secret itself for consistency
          $SubscriptionId = $env:AZURE_SUBSCRIPTION_ID_FROM_CREDS 
          $ClientSecret = $env:SP_CLIENT_SECRET
          
          Write-Host "Attempting to connect with TenantId: $TenantId, ClientId: $ClientId, SubscriptionId: $SubscriptionId"

          # Robust Authentication using Add-AzAccount with PSCredential
          # This approach handles potential nuances with Connect-AzAccount -ServicePrincipal directly.
          $SecureClientSecret = ConvertTo-SecureString -String $ClientSecret -AsPlainText -Force
          $Credential = New-Object System.Management.Automation.PSCredential($ClientId, $SecureClientSecret)
          Add-AzAccount -Credential $Credential -ServicePrincipal -TenantId $TenantId -SubscriptionId $SubscriptionId -ErrorAction Stop

          # Import Az.KeyVault module AFTER authentication
          Import-Module Az.KeyVault -ErrorAction Stop
          
          Write-Host "Generating self-signed certificate with Friendly Name: '$certFriendlyName' and Common Name: '$certCommonName'..."

          $pfxPassword = ConvertTo-SecureString -String "${{ secrets.PFX_PASSWORD }}" -Force -AsPlainText
          
          $cert = New-SelfSignedCertificate `
              -DnsName $certCommonName `
              -CertStoreLocation "Cert:\CurrentUser\My" `
              -FriendlyName $certFriendlyName `
              -NotAfter (Get-Date).AddDays($validityDays) `
              -KeyUsage DigitalSignature, KeyEncipherment `
              -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.1,1.3.6.1.5.5.7.3.2", "2.5.29.19={text}CA=FALSE") `
              -ErrorAction Stop

          Write-Host "Certificate generated successfully. Thumbprint: $($cert.Thumbprint)"

          $pfxPath = "C:\temp\$($certFriendlyName).pfx"
          
          if (-not (Test-Path -Path (Split-Path $pfxPath) -PathType Container)) {
              New-Item -Path (Split-Path $pfxPath) -ItemType Directory -Force
          }

          Export-PfxCertificate -Cert $cert -FilePath $pfxPath -Password $pfxPassword -ErrorAction Stop

          Write-Host "PFX file exported to: $pfxPath"
          
          # Output the PFX path and password so they can be used by subsequent steps
          echo "pfx_file_path=$pfxPath" >> $env:GITHUB_OUTPUT
          echo "pfx_password_raw=${{ secrets.PFX_PASSWORD }}" >> $env:GITHUB_OUTPUT # Pass raw password for secure string conversion in next step

      - name: Import PFX into Azure Key Vault
        shell: pwsh
        # Only run this step if the previous generation step was successful and produced a PFX file
        if: success() && steps.generate_cert_pfx.outputs.pfx_file_path
        env:
          AZURE_CREDS_JSON: ${{ secrets.AZURE_CREDENTIALS }}
          SP_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
          AZURE_SUBSCRIPTION_ID_FROM_CREDS: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
        run: |
          # Parse the AZURE_CREDENTIALS JSON to get SPN details for Connect-AzAccount
          $Creds = ConvertFrom-Json -InputObject $env:AZURE_CREDS_JSON
          $TenantId = $Creds.tenantId
          $ClientId = $Creds.clientId
          $SubscriptionId = $env:AZURE_SUBSCRIPTION_ID_FROM_CREDS
          $ClientSecret = $env:SP_CLIENT_SECRET
          
          # Robust Authentication using Add-AzAccount with PSCredential (re-authenticate for robustness)
          $SecureClientSecret = ConvertTo-SecureString -String $ClientSecret -AsPlainText -Force
          $Credential = New-Object System.Management.Automation.PSCredential($ClientId, $SecureClientSecret)
          Add-AzAccount -Credential $Credential -ServicePrincipal -TenantId $TenantId -SubscriptionId $SubscriptionId -ErrorAction Stop

          # Import Az.KeyVault module AFTER authentication
          Import-Module Az.KeyVault -ErrorAction Stop

          # Retrieve the PFX password and path from the previous step's outputs
          $pfxPassword = "${{ steps.generate_cert_pfx.outputs.pfx_password_raw }}" | ConvertTo-SecureString -AsPlainText -Force
          $pfxFilePath = "${{ steps.generate_cert_pfx.outputs.pfx_file_path }}"

          Write-Host "Importing PFX from '$pfxFilePath' into Key Vault '${{ env.KEY_VAULT_NAME }}'..."

          # Import the PFX into Azure Key Vault
          Import-AzKeyVaultCertificate `
              -VaultName "${{ env.KEY_VAULT_NAME }}" `
              -Name "${{ env.CERTIFICATE_NAME_IN_KV }}" `
              -FilePath $pfxFilePath `
              -Password $pfxPassword `
              -ErrorAction Stop

          Write-Host "Certificate '${{ env.CERTIFICATE_NAME_IN_KV }}' (Friendly Name: '${{ env.CERT_FRIENDLY_NAME }}') imported into Key Vault '${{ env.KEY_VAULT_NAME }}' successfully!"

      - name: Upload PFX as Artifact (Optional)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.CERT_FRIENDLY_NAME }}-pfx
          path: ${{ steps.generate_cert_pfx.outputs.pfx_file_path }} 
          retention-days: 1
