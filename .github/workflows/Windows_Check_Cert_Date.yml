name: Scheduled Key Vault Certificate Renewal (Combined)

on:
  workflow_dispatch: # Allows manual trigger
  schedule:
    - cron: '0 0 * * *' # Run once every day at midnight UTC

env:
  AZURE_SUBSCRIPTION_ID: "51f7ed01-84f6-44ab-aa72-4cfa4a75b9f1" # Global subscription ID
  KEY_VAULT_NAME: "samuelkv"
  CERTIFICATE_NAME_IN_KV: "TestingIIScertificate" # Name of the certificate in Key Vault
  CERT_FRIENDLY_NAME: "TestingIIScertificate"     # The Friendly Name you want for the certificate
  CERT_COMMON_NAME: "TestingIIScertificate"       # Subject Common Name (CN) / DNS Name for the cert
  CERT_VALIDITY_DAYS: "30"                        # How long the cert is valid
  RENEWAL_THRESHOLD_DAYS: "31"

jobs:
  renew_cert_if_needed:
    runs-on: windows-latest # Use a Windows runner for PowerShell certificate commands

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Azure Login
        # This action is responsible for logging in and setting up the Az PowerShell session.
        # We rely on its internal setup for subsequent Az cmdlets.
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true # This explicitly tells it to set up the PowerShell session

      - name: Install Latest Az PowerShell Module (Optional, but good for consistency)
        # This step helps ensure all Az modules are up-to-date,
        # but the core authentication should be handled by azure/login.
        shell: pwsh
        run: |
          Set-PSRepository -Name PSGallery -InstallationPolicy Trusted -ErrorAction Stop
          Install-Module -Name Az -Force -AllowClobber -Scope CurrentUser -ErrorAction Stop
          Import-Module Az -ErrorAction Stop
          Write-Host "Az module updated and imported successfully."

      - name: Get Current Certificate Expiration
        id: get_cert_expiry # Assign an ID to this step to get its outputs
        shell: pwsh
        run: |
          # --- Explicitly import Az.KeyVault module ---
          # This is necessary to make Get-AzKeyVaultCertificate available.
          Import-Module Az.KeyVault -ErrorAction Stop

          # We are now relying solely on the 'azure/login' action to have established the session.
          # Removed: Connect-AzAccount -ServicePrincipal ...

          $KeyVaultName = "${{ env.KEY_VAULT_NAME }}"
          $CertificateName = "${{ env.CERTIFICATE_NAME_IN_KV }}"
          
          Write-Host "Retrieving certificate '$CertificateName' from Key Vault '$KeyVaultName'..."
          try {
              # This cmdlet should now work because azure/login set up the session
              $cert = Get-AzKeyVaultCertificate -VaultName $KeyVaultName -Name $CertificateName -ErrorAction Stop
              $currentExpiryDate = $cert.Expires
              Write-Host "Current certificate '$CertificateName' expires on: $currentExpiryDate"
          }
          catch {
              Write-Error "Failed to retrieve certificate '$CertificateName'. Error: $($_.Exception.Message)"
              echo "daysRemaining=0" >> $env:GITHUB_OUTPUT
              exit 0
          }

          $daysRemaining = ($currentExpiryDate - (Get-Date)).Days
          Write-Host "Days remaining until expiration: $daysRemaining"
          echo "daysRemaining=$daysRemaining" >> $env:GITHUB_OUTPUT

      - name: Generate Self-Signed Certificate and Export PFX
        id: generate_pfx # Assign an ID for its output
        shell: pwsh
        if: steps.get_cert_expiry.outputs.daysRemaining <= env.RENEWAL_THRESHOLD_DAYS
        run: |
          # --- Explicitly import Az.KeyVault module ---
          Import-Module Az.KeyVault -ErrorAction Stop

          # Relying on 'azure/login' for authentication.
          # Removed: Connect-AzAccount -ServicePrincipal ...

          $certFriendlyName = "${{ env.CERT_FRIENDLY_NAME }}"
          $certCommonName = "${{ env.CERT_COMMON_NAME }}"
          $validityDays = ${{ env.CERT_VALIDITY_DAYS }}

          $pfxPassword = ConvertTo-SecureString -String "${{ secrets.PFX_PASSWORD }}" -Force -AsPlainText
          
          $cert = New-SelfSignedCertificate `
              -DnsName $certCommonName `
              -CertStoreLocation "Cert:\CurrentUser\My" `
              -FriendlyName $certFriendlyName `
              -NotAfter (Get-Date).AddDays($validityDays) `
              -KeyUsage DigitalSignature, KeyEncipherment `
              -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.1,1.3.6.1.5.5.7.3.2", "2.5.29.19={text}CA=FALSE")

          $pfxPath = "C:\temp\$($certFriendlyName).pfx"
          Export-PfxCertificate -Cert $cert -FilePath $pfxPath -Password $pfxPassword

          Write-Host "Self-signed certificate '$certFriendlyName' generated and exported to $pfxPath"
          echo "PFX_PATH=$pfxPath" >> $env:GITHUB_OUTPUT
          echo "PFX_PASSWORD_RAW=${{ secrets.PFX_PASSWORD }}" >> $env:GITHUB_OUTPUT

      - name: Import PFX into Azure Key Vault
        shell: pwsh
        if: success() && steps.generate_pfx.outputs.PFX_PATH
        run: |
          # --- Explicitly import Az.KeyVault module ---
          Import-Module Az.KeyVault -ErrorAction Stop

          # Relying on 'azure/login' for authentication.
          # Removed: Connect-AzAccount -ServicePrincipal ...

          $pfxPassword = $env:PFX_PASSWORD_RAW | ConvertTo-SecureString -AsPlainText -Force

          Import-AzKeyVaultCertificate `
              -VaultName "${{ env.KEY_VAULT_NAME }}" `
              -Name "${{ env.CERTIFICATE_NAME_IN_KV }}" `
              -FilePath "${{ steps.generate_pfx.outputs.PFX_PATH }}" `
              -Password $pfxPassword `
              -ErrorAction Stop

          Write-Host "Certificate '${{ env.CERTIFICATE_NAME_IN_KV }}' (with friendly name '${{ env.CERT_FRIENDLY_NAME }}') imported into Key Vault."
