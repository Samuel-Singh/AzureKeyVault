name: Scheduled Key Vault Certificate Renewal (Combined)

on:
  workflow_dispatch: # Allows manual trigger
  schedule:
    - cron: '0 0 * * *' # Run once every day at midnight UTC

env:
  AZURE_SUBSCRIPTION_ID: "51f7ed01-84f6-44ab-aa72-4cfa4a75b9f1"
  KEY_VAULT_NAME: "samuelkv"
  CERTIFICATE_NAME_IN_KV: "TestingIIScertificate" # Name of the certificate in Key Vault
  CERT_FRIENDLY_NAME: "TestingIIScertificate"     # The Friendly Name you want for the certificate
  CERT_COMMON_NAME: "TestingIIScertificate"       # Subject Common Name (CN) / DNS Name for the cert
  CERT_VALIDITY_DAYS: "30"                        # How long the cert is valid
  RENEWAL_THRESHOLD_DAYS: "31"

jobs:
  renew_cert_if_needed:
    runs-on: windows-latest # Use a Windows runner for PowerShell certificate commands

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Azure Login
        id: az_login # Keep ID to reference its outputs
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true # Crucial for Az PowerShell session setup

      - name: Get Current Certificate Expiration
        id: get_cert_expiry # Assign an ID to this step to get its outputs
        shell: pwsh
        run: |
          # Pass outputs as PowerShell variables
          $TenantId = "${{ steps.az_login.outputs.tenantId }}"
          $ClientId = "${{ steps.az_login.outputs.clientId }}"
          $SubscriptionId = "${{ steps.az_login.outputs.subscriptionId }}"
          $ClientSecret = "${{ secrets.AZURE_SP_CLIENT_SECRET }}" # Direct reference to secret

          # --- Explicitly import Az.KeyVault module ---
          Import-Module Az.KeyVault -ErrorAction Stop

          # --- Explicitly connect Az PowerShell using passed variables ---
          Connect-AzAccount -ServicePrincipal `
              -TenantId $TenantId `
              -ApplicationId $ClientId `
              -ClientSecret $ClientSecret `
              -SubscriptionId $SubscriptionId `
              -ErrorAction Stop
          
          $KeyVaultName = "${{ env.KEY_VAULT_NAME }}"
          $CertificateName = "${{ env.CERTIFICATE_NAME_IN_KV }}"
          
          Write-Host "Retrieving certificate '$CertificateName' from Key Vault '$KeyVaultName'..."
          try {
              $cert = Get-AzKeyVaultCertificate -VaultName $KeyVaultName -Name $CertificateName -ErrorAction Stop
              $currentExpiryDate = $cert.Expires
              Write-Host "Current certificate '$CertificateName' expires on: $currentExpiryDate"
          }
          catch {
              Write-Error "Failed to retrieve certificate '$CertificateName'. Error: $($_.Exception.Message)"
              echo "daysRemaining=0" >> $env:GITHUB_OUTPUT
              exit 0
          }

          $daysRemaining = ($currentExpiryDate - (Get-Date)).Days
          Write-Host "Days remaining until expiration: $daysRemaining"
          echo "daysRemaining=$daysRemaining" >> $env:GITHUB_OUTPUT

      - name: Generate Self-Signed Certificate and Export PFX
        id: generate_pfx # Assign an ID for its output
        shell: pwsh
        if: steps.get_cert_expiry.outputs.daysRemaining <= env.RENEWAL_THRESHOLD_DAYS
        run: |
          # Pass outputs as PowerShell variables
          $TenantId = "${{ steps.az_login.outputs.tenantId }}"
          $ClientId = "${{ steps.az_login.outputs.clientId }}"
          $SubscriptionId = "${{ steps.az_login.outputs.subscriptionId }}"
          $ClientSecret = "${{ secrets.AZURE_SP_CLIENT_SECRET }}" # Direct reference to secret

          # --- Reconnect Az PowerShell in this step for robustness ---
          Connect-AzAccount -ServicePrincipal `
              -TenantId $TenantId `
              -ApplicationId $ClientId `
              -ClientSecret $ClientSecret `
              -SubscriptionId $SubscriptionId `
              -ErrorAction Stop

          $certFriendlyName = "${{ env.CERT_FRIENDLY_NAME }}"
          $certCommonName = "${{ env.CERT_COMMON_NAME }}"
          $validityDays = ${{ env.CERT_VALIDITY_DAYS }}

          $pfxPassword = ConvertTo-SecureString -String "${{ secrets.PFX_PASSWORD }}" -Force -AsPlainText
          
          $cert = New-SelfSignedCertificate `
              -DnsName $certCommonName `
              -CertStoreLocation "Cert:\CurrentUser\My" `
              -FriendlyName $certFriendlyName `
              -NotAfter (Get-Date).AddDays($validityDays) `
              -KeyUsage DigitalSignature, KeyEncipherment `
              -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.1,1.3.6.1.5.5.7.3.2", "2.5.29.19={text}CA=FALSE")

          $pfxPath = "C:\temp\$($certFriendlyName).pfx"
          Export-PfxCertificate -Cert $cert -FilePath $pfxPath -Password $pfxPassword

          Write-Host "Self-signed certificate '$certFriendlyName' generated and exported to $pfxPath"
          echo "PFX_PATH=$pfxPath" >> $env:GITHUB_OUTPUT
          echo "PFX_PASSWORD_RAW=${{ secrets.PFX_PASSWORD }}" >> $env:GITHUB_OUTPUT

      - name: Import PFX into Azure Key Vault
        shell: pwsh
        if: success() && steps.generate_pfx.outputs.PFX_PATH
        run: |
          # Pass outputs as PowerShell variables
          $TenantId = "${{ steps.az_login.outputs.tenantId }}"
          $ClientId = "${{ steps.az_login.outputs.clientId }}"
          $SubscriptionId = "${{ steps.az_login.outputs.subscriptionId }}"
          $ClientSecret = "${{ secrets.AZURE_SP_CLIENT_SECRET }}" # Direct reference to secret

          # --- Reconnect Az PowerShell in this step for robustness ---
          Connect-AzAccount -ServicePrincipal `
              -TenantId $TenantId `
              -ApplicationId $ClientId `
              -ClientSecret $ClientSecret `
              -SubscriptionId $SubscriptionId `
              -ErrorAction Stop

          $pfxPassword = $env:PFX_PASSWORD_RAW | ConvertTo-SecureString -AsPlainText -Force

          Import-AzKeyVaultCertificate `
              -VaultName "${{ env.KEY_VAULT_NAME }}" `
              -Name "${{ env.CERTIFICATE_NAME_IN_KV }}" `
              -FilePath "${{ steps.generate_pfx.outputs.PFX_PATH }}" `
              -Password $pfxPassword `
              -ErrorAction Stop

          Write-Host "Certificate '${{ env.CERTIFICATE_NAME_IN_KV }}' (with friendly name '${{ env.CERT_FRIENDLY_NAME }}') imported into Key Vault."
